#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

class FibonacciHeap {
private:
    struct Node {
        int key;
        int degree;
        bool marked;
        Node* parent;
        Node* child;
        Node* left;
        Node* right;
        
        Node(int k) : key(k), degree(0), marked(false), 
                     parent(nullptr), child(nullptr), 
                     left(this), right(this) {}
    };
    
    Node* minNode;
    int count;
    
    void addToRootList(Node* node) {
        node->left = minNode;
        node->right = minNode->right;
        minNode->right->left = node;
        minNode->right = node;
    }
    
    void consolidate() {
        int maxDegree = floor(log(count) / log(2)) + 1;
        vector<Node*> degreeTable(maxDegree + 1, nullptr);
        
        vector<Node*> nodes;
        Node* current = minNode;
        do {
            nodes.push_back(current);
            current = current->right;
        } while (current != minNode);
        
        for (Node* node : nodes) {
            Node* x = node;
            int d = x->degree;
            while (degreeTable[d] != nullptr) {
                Node* y = degreeTable[d];
                if (x->key > y->key) {
                    swap(x, y);
                }
                heapLink(y, x);
                degreeTable[d] = nullptr;
                d++;
            }
            degreeTable[d] = x;
        }
        
        minNode = nullptr;
        for (Node* node : degreeTable) {
            if (node != nullptr) {
                if (minNode == nullptr) {
                    minNode = node;
                } else if (node->key < minNode->key) {
                    minNode = node;
                }
            }
        }
    }
    
    void heapLink(Node* y, Node* x) {
        y->left->right = y->right;
        y->right->left = y->left;
        
        y->parent = x;
        if (x->child == nullptr) {
            x->child = y;
            y->left = y;
            y->right = y;
        } else {
            y->left = x->child;
            y->right = x->child->right;
            x->child->right->left = y;
            x->child->right = y;
        }
        
        x->degree++;
        y->marked = false;
    }
    
public:
    FibonacciHeap() : minNode(nullptr), count(0) {}
    
    void insert(int key) {
        Node* node = new Node(key);
        if (minNode == nullptr) {
            minNode = node;
        } else {
            addToRootList(node);
            if (key < minNode->key) {
                minNode = node;
            }
        }
        count++;
    }
    
    int findMin() {
        return minNode ? minNode->key : -1;
    }
    
    int extractMin() {
        Node* z = minNode;
        if (z != nullptr) {
            if (z->child != nullptr) {
                Node* child = z->child;
                do {
                    Node* nextChild = child->right;
                    addToRootList(child);
                    child->parent = nullptr;
                    child = nextChild;
                } while (child != z->child);
            }
            
            z->left->right = z->right;
            z->right->left = z->left;
            
            if (z == z->right) {
                minNode = nullptr;
            } else {
                minNode = z->right;
                consolidate();
            }
            
            count--;
            int key = z->key;
            delete z;
            return key;
        }
        return -1;
    }
};
